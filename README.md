# Malware Visualization

So as a reminder, the goal of this research is to develop a tool that generates high level representations or visualizations of malware, to facilitate an analysts initial understanding of some function or the malware as a whole. The main problem I'm trying to solve, is that when reversing malware you might spend a considerable amount of time digging into the disassembly of some function to figure out that it, for example, waits until it receves some file from the network, and writes it to disk. And the idea here is to visualize the function in some way that it's instantly recognizable what the function does. Though, as I'll explain later, I've got some other ideas of how this might be used.

The half of this study is writing the analyses, and the second half is developing the visualizations. So thus far I've been working on writing the analyses. My initial approach has been to first write a "tagging system", which is mostly complete. The idea here is to have a database of system and library calls, some specification of what each one does, and then to scan the program, tagging the use of each call with what it does. 

Each definition in the database is currently a sequence of statements in a custom pseudo-language that summarizes the side effects of the call. So for example if I take the `send(...)` networking call, the statement I have in my database for it are something like "WRITE(arg2, socket)". For recv I the statement is "READ(socket, arg?)". At the moment all the calls I have in my database are summarized with "WRITE", "READ", and "MOVE" statements.

Ok so once each call is tagged with the appropriate statements. The next step is to find the dataflow between them. And I'm most of the way done with this step, it's not compelteley working yet but it should be done before I submit my midterm report. Currently what I'm using the binaryninja MLIL (which is a middle level intermediate representation), to track the data flow between each tagged element. There are multiple reasons for the data flow tracking. First, it allows me to replace arguments in statements with actual values. So for example, a call might be tagged that it writes the first the first argument to a file, and data flow might reveal that this argument comes a network recv, so this can be simplified to WRITE(network data, file).

So I've impelemented most of what I've described so far, any questions on that before I get to where I'm hoping to go with it. 

Once all analyses above are working, there are several approaches to displaying it in a useful way. The first one I want to try is just a simple graph view, where each statement is a node and the data flow is graphed between them. This could be done at the function level or the global level, depending on how complex the binary is. 

An extension of this could be to generate different global models, but let the user specify which side effects it should model. For example, maybe you're wanting to fuzz the binary, so you generate a model just of the file reads. Or maybe you want to look for a backdoor in the binary, so you model just the network reads and command line writes, to see if there might be functionality that allow and attacker to run arbitrary commands over the network. 

The second "class" of approaches I'd want to try is writing further analyses that use the high level representation. For example, there are many attempts at using machine learning to detect if some file is malicious. But machine learning on, for example, binary data, is picking out basically things that weakly correlate with it being malicious. What we really want, is to classify some file as malicious/non-malicious directly based on the malicious functionality, like if it runs arbitrary network data as a command. So it would be interesting to try to write a malware classifier based on this.

There are also other things we could do with machine learning. For example, if we generate a long sequence of statements for each function, we might be able to re-use some algorithms from the text summarization literature, to generate a summary for each function.

---

Do this in binaryninja because:
 - Can go on binaryninja stream
 - Can use MLIL and HLIL for data flow analysis
 - Can use tagging system
 - Has best UI of all the tools
 - Python is easiest for machine learning

## Research ideas
 - Granular malware identification with machine learning on function semantics
 - Generating funciton description with generative grammar
 - Improve reverse engineering workflow using data analysis on their behavior.
 - Generate reports using some r2report code on how every malware in PMA works

---

## Schedule
### Weeks 1-3
 - Write plugin to facilitate malware tagging
 - Analyze malware to design visualizations
   - Tag each malware function with size, complexity, call count, system call list, function classification (network, OS, etc) and importance
   - Run data analysis to correlate various function features with importance
   - Machine learning model to predict importance
 - Determine what data to tag
 - Prototype custom graph
 - Prototype custom function listing
 - Think about applications of recommender systems, other new ideas

### Weeks 4-6
 - Write analysis pass to identify important elements
 - Write data-flow tracer or integrate BAP taint
 - Graph function summary using these elements
 - Understand if generative grammar is possible
 - Tag strings with sentiment analysis

### Weeks 7-9
 - Generative grammar function descriptions
 - Machine learning malware classification on 1) high level representation, 2) generative grammar function description
 - Rate functions by their maliciousness?

### Weeks 10-12

### Weeks 13-15

 


---

## Final Plan
 - Basic plugin for custom function listing
   - Dynamic function sorting (using importance, height in call tree, understandability (are calls known), complexity, hide some
   - List in tree form, use heuristics to organize like original code base folder structure
   - Function classification (networking, file, memory, etc)
   - Understandablity rating
 - Function level visualization
   - Build function summary graph
   - Extract important features to add to function summary
   - Simplify function summary graph
   - Propogate info using data flow or HLIL variables. For example, can specify file name from read, propogates name to all file writes and network sends.
   - ALIL (abstract level il)
 - Function generative grammar
   - Generative grammar to create description for function
   - Add description to custom function listing
 - Binary level visualization
   - Visualize entire call graph
   - Label call graph with high level properties
   - Simplify entire call graph
   - Propogate info using data flow or HLIL variables. For example, can specify file name from read, propogates name to all file writes and network sends.
 - Binary ninja views enhancements
   - Add dangerous functions as red dots on feature map
   - Automatically rename functions
 - Survey
   - Plugin to record reversing session - time spent in function, function importance rating, function visit order
   - Get participants to reverse engineer the malware. See if total time, time spent in unimportant functions, etc are reduced. Split data set into A and B set, participants can use visualization tools on half the set, see if time to understand malware is reduced.
 - Debugger stuff
 

---

## Concrete Ideas
### New function list
 - Sort functions by importance, hide some
 - Classify function as "networking", "file", etc in column
 - Generate text description of what function does
 - Column for understandability rating, based on if calls are known, complexity, etc
 - If function only called by one other, then list it as a sub-function in the list (indented and below the calling function)
 
### RE observing statistics
 - Take data of reverse engineers analyzing malware
 - Run statistical analysis to determine what high-level features correlate with analysis time and order
 - Use high level features like function classification, complexity, height in call tree, etc with statistical analysis
 - Have reverse engineers mark the importance of each function to use with statistical analysis
 
### Function level visualizations
 - Generative grammar description for what function does
 - Advanced function summary graph with various properties

### Binary level visualizations
 - Call graph of the entire binary, but each node contains high-level properties. Only include important functions.

### Debugger
 - Instrument run with qiling/pin/frida. Highlight graph with code coverage, labeling function call args. Generate report summarizing run. Can click on places in report to inspect memory, etc.

---

## Other
 - Binary visualization to facilitate exploitation
 - Dynamic binary visualization for debugging
 - Visualize the last debug session
 - Something with abstract interpretation
 - Visualize symbolic execution in 3D
 - Recommender system for function investigation order
